Basic Syntax:

Commands are split by new-line, except where there is a missing closed parenthese.
eg.   1 x = 5      is valid and equivalent to    1 x = 5  
      2 x = x + 5                                2 x = x + 5
      3 y = cnum(x - 5)                          3 y = cnum(x - 5)
      4 y = cnum(45                              4 y = cnum(45 + 4)
      5    +
      6   4)

References are assigned using '='
Single-line comments start with '#'
Mutli-line comments start and end with '##'
Whitespace is not considered anywhere except for when found within string literals.

OPERATOR PRECEDENCE TABLE

x = x + x  is valid and will result in x being doubled if it is a register type (primitive).
x = x + x + x + x is also valid and will result in x being quadrupled if it is a regsiter type (primitive).

Types:
Primitives:
1. Qubit (qubit)
  Defined as 1 quantum bit. Can be initialised ([state]) to 1, 0, true, false, or into a quantum state defined by a 2*1 matrix, its 1*2 transpose, or a string representation*.
  Syntax:
  x = qubit([state])
  or
  x = qubit()  (defaults to state |0>)

2. C-bit (cbit)
  Defined as 1 classical bit. Can be initialised ([value]) to 1, 0, true, or false.
  Syntax:
  x = bit([value])
  or
  x = bit() (defaults to 0/false)
  or
  x = true/false

3. Q-num (qnum)
  Defined as an number represented by a register of qubits. Can be initialised into a state defined by a n*1 matrix, its 1*n transpose, or a string representation*.
  Numbers are encoded and stored in binary in the computational basis either with floating point or 2's complement.
  Syntax:
  x = qnum([value])
  x = qnum(5)
  or
  x = qnum(5.123)
  or
  x = qnum([state])

4. Phase-encoded Q-num (qnump)
  Defined as an number represented by a register of qubits. Can be initialised into a state defined by a n*1 matrix, its 1*n transpose, or a string representation*.
  Numbers are encoded and stored in the phase elemenet of the register using Quantum Fourier Transform.
  Syntax:
  x = qnump([value])
  x = qnump(5)
  or
  x = qnump(5.123)
  or
  x = qnump([state])


5. C-num (cnum)
  Defined as a number represented by a register of classical bits. Can be initialised to a number.
  Syntax:
  x = cnum(5)
  or
  x = 5
  or
  x = cnum(5.5)
  or
  x = 5.5

6. Q-string (qstr)
  Defined as a string represented by a register of qubits. Can be initialised to a string of characters.
  Strings are encoded using ASCII. Each character requires 7 qubits.
  Syntax:
  x = qstr("")

7. Shortend Q-string (qstrs)
  Defined as a string represented by a register of qubits. Can be initialised to a string of characters.
  Strings are encoded using a non-alphanumeric version of ITA2. Each character requires 5 qubits.
  Syntax:
  x = qstrs("")

8. Shortend Cyrillic Q-string (qstrc)
  Defined as a string represented by a register of qubits. Can be initialised to a string of characters.
  Strings are encoded using a non-alphanumeric version of MTK2. Each character requires 5 qubits.
  Syntax:
  x = qstrc("")

9. Extended Q-string (qstre)
  Defined as a string represented by a register of qubits. Can be initialised to a string of characters.
  Strings are encoded using UTF-8. Each character requires 8-32 qubits.
  Syntax:
  x = qstre("")

10. C-string (cstr)
  Defined as a string represented by a register of classical bits. Can be initialised to a string of characters.
  Strings are encoded using ASCII. Each character requires 7 bits.
  Syntax:
  x = cstr("")
  or
  x = ""

11. Shortend C-string (cstrs)
  Defined as a string represented by a register of classical bits. Can be initialised to a string of characters.
  Strings are encoded using a non-alphanumeric version of ITA2. Each character requires 5 bits.
  Syntax:
  x = cstrs("")

12. Shortend Cyrillic C-string (cstrc)
  Defined as a string represented by a register of classical bits. Can be initialised to a string of characters.
  Strings are encoded using a non-alphanumeric version of MTK2. Each character requires 5 bits.
  Syntax:
  x = cstrc("")
  or
  x = "[Compatible string containing characters not compatible with ASCII]"

13. Extended C-string (cstre)
  Defined as a string represented by a register of classical bits. Can be initialised to a string of characters.
  Strings are encoded using UTF-8. Each character requires between 8-32 bits.
  Syntax:
  x = cstre("")
  or
  x = "[Compatible string containing characters not compatible with ASCII or MTK2]"

Data Structures:
1. List (list)
  Defined as an ordered collection of primatives, references, or data structures. Can be initialised with type arguements, list members, or length. Initializing with types limits the type of reference the list may contain.
  Syntax:
  x = list("type", [comma-separated list of types])      eg. x = list("type",[cnum,cstr,set,matrix])  Note: "type" must be a cstr containing "type"
  or
  x = list([comma-separated list of members])            eg. x = list([x,y,"cat",5])
  or
  x = list(cnum)                                         eg. x = list(3) => [null,null,null]
  or
  x = list(cnum,[comma-separated list of types])         eg. x = list(3,[cnum]) => [0,0,0]

2. Set (set)
  Defined as an unordered collection of primatives, references, or data structures. Can be initialised with type arguements or set members. Initializing with types limits the type of reference the set may contain.
  Syntax:
  x = set("type", [comma-separated list of types])      eg. x = set("type",[cnum,cstr,set,matrix])  Note: "type" must be a cstr containing "type"
  or
  x = set([comma-separated list of members])            eg. x = set([x,y,"cat",5])

3. Matrix (matrix)
  Defined as an 2D nested list where all inner lists have the same length. Can be initiliased with a list of lists, indiviudal references, or by type. Initializing with types limits the type of reference the matrix may contain.
  Syntax:
  x = [i00,i0n;in0,inn]                                eg. x = [1,2;3,4] makes the following matrix   [ 1 2 ]
  or                                                                                                  [ 3 4 ]
  x = matrix([i00,i0n;in0,inn])                        Note: that the entries can be references of any type.
  or
  x = matrix("type", [comma-separated list of types])  eg. x = matrix("type",[cnum,cstr,set,struct]) Note: "type" must be a cstr containing "type"
  or
  x = matrix("list", [list0,list1,listn]) Note: "list" must be a cstr containing "list"

4. Map (map)
  Defined as a set of tuples. Can be initialized with 2 lists, a 2*n or n*2 matrix, indivual references, or by type. Initializing with types limits the type of reference the matrix may contain.
  Syntax:
  x = map(listk,listv)
  or
  x = map(matrix)
  or
  x = map([comma seperate list of key-value pairs])  eg. x = map([key0-value0,key1-value1,keyn-valuen])
  or
  x = map("type", [comma-separated list of types])   eg. x = map("type",[cnum,cstr,set,struct])   Note: "type" must be a cstr containing "type"
  or
  x = [comma seperate list of key-value pairs]       eg. x = [key0-value0,key1-value1,keyn-valuen]

5. Custom Data Structure (struct)
  Defined as a custom data structure combining several types, primitves, data structures, and other elements. Can be initialized with a map of key-value pairs.
  Syntax:
  x = struct([map of name-type pairs])                eg. x = struct([number-cnum,string-cstr,qubit-qubit])
  x.name = access to single element                   eg. x.number = 5

Quantum Circuit Design:
1. Gate (gate)
  Defined as a reversible, unitary transformation that acts on qubits. Can be initialized with a matrix.
  Syntax:
  x = gate(matrix)
  or 
  x = gate([i00,i0n;in0,inn])

2. Circuit (circ)
  Defined as an ordered sequence of quantum gates applied to a set of qubits. Can be initialised with a collection of qubits, matrix, number, or string, and a 2d list or matrix of gates.
  Syntax:
    x = circ([list of qubits, qnum, state vector as a matrix, or any q-string variant],[2D list of gates, matrix of gates, or block])
    or
    x = circ(number, [2D list of gates, matrix of gates, or block])
    or
    x = circ("", [2D list of gates, matrix of gates, or block])

  Further information: 
    The first argument determines the number of and initial states of the qubits in the circuit.
    Therefore, it must represent a register of qubits in some way (list,qnum,qsrt variants) , or be made to represent such (numbers, strings).

    The second argument determines the subsequent gates by assigning each qubit a list of gates of equal length. Position in the lists signfies time.
    i.e. All gates at index 0 are applied first, then index 1, and so forth.
    Empty elements (null) are treated as the identity.

    Below is an example circuit: circ([1;0;0;0], [ xgate, null; igate, zgate]) which follows circ([state vector as a matrix], [matrix of gates])

    |0>--[xgate]--[igate]--
    |0>--[igate]--[zgate]--
  
3. Blocks (block)
  Defined as a grouped sequence of gates for a specific number of qubits. Can be initialized using a 2D list or a matrix of gates.
  Syntax:
  x = block([list0,list1,listn])
  or
  x = block(matrix)

  Further infortmation:
    A block save a sequence of gate across several undefined qubits by assigning each a list of gates of equal length. Position in the lists signfies time.
    i.e. All gates at index 0 would be applied first, then index 1, and so forth.
    Empty elements (null) are treated as the identity.

    Below is an example block: block([ xgate, null; igate, zgate]) which follows block(matrix)

   --[xgate]--[igate]--
   --[igate]--[zgate]--

Operators:

1. Addition
      Adds 2 registers
      Syntax: x = Register1 + Register2
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

      or 

      Adds 2 matrices
      Syntax: x = Matrix1 + Matrix2
      Allowed types for x, Matrix1, & Matrix2: matrix


2. Subtraction
      Subtracts Register2 from Register1 (Register1 + -(Register2))
      Syntax: x = Register1 - Register2
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

3. Multiplication
      Multiplies 2 registers.
      Syntax: x = Register1 * Register2
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

4. Division
      Divides Register1 by Register2
      Syntax: x = Register1 / Register2
      Example: 10 / 4 = 2.5
      Note that this division is exact, and will return decimal values. (Maximum bit-length of x=Register1+Register2, x is rounded off at length)
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

5. Concatenation
      Combines 2 collections
      Syntax: x = Collection1 + Collection2
      Allowed types for x, Collection1, & Collection2: List, Set, Map
      Example: [1,2,3] + [3,2,1] -> [1,2,3,3,2,1]

      or

      Combines 2 strings
      Syntax: x = concat(String1, String2)
      Allowed types for x, String1, & String2: qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      String1 & String2 will be decoded into text according to their own schemes, combined, & encoded according to x's scheme.


6. Modulus
      Returns the remainder incurred when attempting to divide Register1 by Register2
      Syntax: x = Register1 % Register2
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

7. Exponentation
      Returns Register1 raised to the Register2-th power
      Syntax x = Register1 ^ Register2
      Example: 5 ^ 2 => 25
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.


8. And
      Returns the outcome of bitwise logic operation Register1 and Register2
      Syntax x = Register1 and Register2
      Example: 5 and 3 => 1
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

9. Or
      Returns the outcome of the bitwise logic operation Register1 or Register2
      Syntax x = Register1 or Register2
      Example: 5 or 2 => 8
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

10. Bitwise Negation
      Returns a binary negation of the input register.
      Syntax x = not Register
      Example: not 5 => 2
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

11. Equality
      Returns 1-bit boolean based on whether 2 registers are numerically equal
      Syntax x = Register1 == Register2
      Example: 5 == 5 => 1/true
      Allowed types for x: qubit, cbit.
      Allowed types for Register1, & Register2: qubit, cbit, qnum, qnump, cnum.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

12. Identicality
      Returns 1-bit boolean based on whether 2 variables encoded the same way.
      Syntax x = Var1 issame Var2
      Example: Var1 = Q-String encoded as 011000110110000101110100 ("CAT"), Var2 = C-num also encoded as 011000110110000101110100 (6513012)
            Var1 issame Var2 => 1/true
      Allowed types for x: qubit, cbit.
      Allowed types for Var1 & Var2: any.

13. Type-Identicality
      Returns 1-bit boolean based on whether to variables of the same type (quantum/classical ignored) are encoded the same way.
      Syntax x = Var1 is Var2
      Example: Var1 = Q-string "CAT", Var2 = C-string "CAT". Var1 is Var2 => 1/true.
      Note: if Var1 & Var2 are not of the same type(quantum/classical ignored), it will return 0/false.
      Allowed types for x: qubit, cbit.
      Allowed types for Var1 & Var2: any.

14. Strict Type-Identicality
      Returns 1-bit boolean based on whether to variables of the same type are encoded the same way.
      Syntax x = Var1 is! Var2
      Example: Var1 = Q-string "CAT", Var2 = Q-string "CAT". Var1 is! Var2 => 1/true.
      Note: if Var1 & Var2 are not of the same type, it will return 0/false. (QUANTUM/CLASSICAL IS NOT IGNORED)
      Allowed types for x: qubit, cbit.
      Allowed types for Var1 & Var2: any.

15. Boolean Negation
      Flips a boolean between 1/true and 0/false
      Syntax x = !Boolean
      Example: Boolean = 1/true. !Boolean => 0/false
      Allowed types for x & Boolean: qubit, cbit.

16. Less-than
      Returns 1/true if Register1 is numerically less-than Register2
      Syntax: x = Register1 < Register2
      Allowed types for x: qubit, cbit.
      Allowed types for Register1 & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

17. Greater-than
      Returns 1/true if Register1 is numerically greater-than Register2
      Syntax: x = Register1 > Register2
      Allowed types for x: qubit, cbit.
      Allowed types for Register1 & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

18. Less-than or Equal-to
      Returns 1/true if Register1 is numerically less-than or equal-to Register2
      Syntax: x = Register1 <= Register2
      Allowed types for x: qubit, cbit.
      Allowed types for Register1 & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

19. Less-than
      Returns 1/true if Register1 is numerically greater-than or equal-to Register2
      Syntax: x = Register1 >= Register2
      Allowed types for x: qubit, cbit.
      Allowed types for Register1 & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

20. Integer Division
      Divides Register1 by Register2, and cuts off any decimal values
      Syntax: x = Register1 // Register2
      Example: 10 // 4 => 2
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

21. Type-Checking
      Returns 1/true if 2 variables are of the same type, ignoring the quantum/classical divide
      Syntax: x = Var1 istypeof Var2
      Allowed types for x: qubit, cbit.
      Allowed types for Var1 & Var2: any.

22. Strict Type-Checking
      Returns 1/true if 2 variables are of the same type.
      Syntax: x = Var1 istypeof! Var2
      Allowed types for x: qubit, cbit.
      Allowed types for Var1 & Var2: any.

23.  Left Shift
      Bitwise shifts a register left
      Syntax x = <<Register
      Allowed types of register: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre

24.  Right Shift
      Bitwise shifts a register right
      Syntax x = >>Register
      Allowed types of register: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre

25. Either-or
      Returns the result of the bitwise operation Register1 XOR Register2
      Syntax x = Register1 xor Register2
      Example: 5 xor 3 => 6
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

26. Not-and
      Returns the result of the bitwise operation Register1 NAND Register2
      Syntax x = Register1 xor Register2
      Example: 5 nand 4 => 3
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

27. Not-either-or
      Returns the result of the bitwise operation Register1 XNOR Register2
      Syntax x = Register1 xnor Register2
      Example: 5 nand 4 => 6
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

29. Not-or
      Returns the result of the bitwise operation Register1 NOR Register2
      Syntax x = Register1 nor Register2
      Example: 5 nand 4 => 2
      Allowed types for x, Register1, & Register2: qubit, cbit, qnum, qnump, cnum, qstr, qstrs, qstrc, qstre, cstr, ctrs, ctrc, cstre.
      All non-numeric types will be treated as if they were (2's complement) using their register values.

30. Tensor
31. Dot/Inner-Product
32. Outer Product
33. Cross Product
34. Trace
35. Partial Trace
36. Measurement
37. Predicted Measurment (Quantum-peek)
38. Expectation Value
39. Reference Swap
40. Collection Cut
41. Collection add
42. Colleciton place
43. Collection delete
44. Collection read
45. Matrix subtraction
46. Matrix multiplicaiton
47. determinant
48. matrix edit
49. matrix add-column
50. matrix add-row
51. matrix read
52. matrix delete row
53. matrix delete column
54. print
55. State of quantum
56. type casting
57. make gate control
58. evals
59. evec
60. transpose
61. conjugate transpose
62. solve for x
63. solve system for (vars)
64. Run circuit w/ noise+time (iterations)
65. Difference operator (reveals how smth has changed)
66. Parallel functin exec. (easy threads)
67. Threads (hard threads)
68. gate's in block/circuit
69. qubits in block circuit
70. depth of block / circuit
71. substring
72. read file
73. write to file
74. standardized save format for gate, block, and circuit
75. log
76. sin
77. cos
78. pi
79. e
80. arcsin
81. arccos
82. tan
83. arctan
84. sec
85. arcsec
86. csc
87. arccsc
88. sinh
89. cosh
90. mean
91. variance
92. standard deviation
93. derivative
94. integral
95. min gate set required for circuit
96. do 2 circuits make same output
97. is unitary?



Control Flow:
1. Conditional (if, else, else if)
2. For Loop (break)
3. While Loop (break)
4. Repeat n-times loop
5. For-each n in y loop

Error Catching
1. try, catch, throw, run "x code" if caught

Function Definitions

Library Definition and Use

ADD BIT LIMITS TO ALL TYPE DEFS!!
